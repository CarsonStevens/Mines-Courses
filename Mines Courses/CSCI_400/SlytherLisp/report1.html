<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <link href="assets/style.css" rel="stylesheet" type="text/css"/></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function find_all(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sort_column(elem) {
    toggle_sort_states(elem);
    var colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    var key;
    if (elem.classList.contains('numeric')) {
        key = key_num;
    } else if (elem.classList.contains('result')) {
        key = key_result;
    } else {
        key = key_alpha;
    }
    sort_table(elem, key(colIndex));
}

function show_all_extras() {
    find_all('.col-result').forEach(show_extras);
}

function hide_all_extras() {
    find_all('.col-result').forEach(hide_extras);
}

function show_extras(colresult_elem) {
    var extras = colresult_elem.parentNode.nextElementSibling;
    var expandcollapse = colresult_elem.firstElementChild;
    extras.classList.remove("collapsed");
    expandcollapse.classList.remove("expander");
    expandcollapse.classList.add("collapser");
}

function hide_extras(colresult_elem) {
    var extras = colresult_elem.parentNode.nextElementSibling;
    var expandcollapse = colresult_elem.firstElementChild;
    extras.classList.add("collapsed");
    expandcollapse.classList.remove("collapser");
    expandcollapse.classList.add("expander");
}

function show_filters() {
    var filter_items = document.getElementsByClassName('filter');
    for (var i = 0; i < filter_items.length; i++)
        filter_items[i].hidden = false;
}

function add_collapse() {
    // Add links for show/hide all
    var resulttable = find('table#results-table');
    var showhideall = document.createElement("p");
    showhideall.innerHTML = '<a href="javascript:show_all_extras()">Show all details</a> / ' +
                            '<a href="javascript:hide_all_extras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    find_all('.col-result').forEach(function(elem) {
        var collapsed = get_query_parameter('collapsed') || 'Passed';
        var extras = elem.parentNode.nextElementSibling;
        var expandcollapse = document.createElement("span");
        if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add("collapsed");
            expandcollapse.classList.add("expander");
        } else {
            expandcollapse.classList.add("collapser");
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener("click", function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains("collapsed")) {
                show_extras(event.currentTarget);
            } else {
                hide_extras(event.currentTarget);
            }
        });
    })
}

function get_query_parameter(name) {
    var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () {
    reset_sort_headers();

    add_collapse();

    show_filters();

    toggle_sort_states(find('.initial-sort'));

    find_all('.sortable').forEach(function(elem) {
        elem.addEventListener("click",
                              function(event) {
                                  sort_column(elem);
                              }, false)
    });

};

function sort_table(clicked, key_func) {
    var rows = find_all('.results-table-row');
    var reversed = !clicked.classList.contains('asc');
    var sorted_rows = sort(rows, key_func, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    var thead = document.getElementById("results-table-head");
    document.getElementById('results-table').remove();
    var parent = document.createElement("table");
    parent.id = "results-table";
    parent.appendChild(thead);
    sorted_rows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName("BODY")[0].appendChild(parent);
}

function sort(items, key_func, reversed) {
    var sort_array = items.map(function(item, i) {
        return [key_func(item), i];
    });
    var multiplier = reversed ? -1 : 1;

    sort_array.sort(function(a, b) {
        var key_a = a[0];
        var key_b = b[0];
        return multiplier * (key_a >= key_b ? 1 : -1);
    });

    return sort_array.map(function(item) {
        var index = item[1];
        return items[index];
    });
}

function key_alpha(col_index) {
    return function(elem) {
        return elem.childNodes[1].childNodes[col_index].firstChild.data.toLowerCase();
    };
}

function key_num(col_index) {
    return function(elem) {
        return parseFloat(elem.childNodes[1].childNodes[col_index].firstChild.data);
    };
}

function key_result(col_index) {
    return function(elem) {
        var strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
                       'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[col_index].firstChild.data);
    };
}

function reset_sort_headers() {
    find_all('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    find_all('.sortable').forEach(function(elem) {
        var icon = document.createElement("div");
        icon.className = "sort-icon";
        icon.textContent = "vvv";
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove("desc", "active");
        elem.classList.add("asc", "inactive");
    });
}

function toggle_sort_states(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        reset_sort_headers();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function is_all_rows_hidden(value) {
  return value.hidden == false;
}

function filter_table(elem) {
    var outcome_att = "data-test-result";
    var outcome = elem.getAttribute(outcome_att);
    class_outcome = outcome + " results-table-row";
    var outcome_rows = document.getElementsByClassName(class_outcome);

    for(var i = 0; i < outcome_rows.length; i++){
        outcome_rows[i].hidden = !elem.checked;
    }

    var rows = find_all('.results-table-row').filter(is_all_rows_hidden);
    var all_rows_hidden = rows.length == 0 ? true : false;
    var not_found_message = document.getElementById("not-found-message");
    not_found_message.hidden = !all_rows_hidden;
}
</script>
    <h1>report1.html</h1>
    <p>Report generated on 20-Feb-2019 at 10:15:38 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v1.20.0</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Packages</td>
        <td>{&apos;pytest&apos;: &apos;4.3.0&apos;, &apos;py&apos;: &apos;1.7.0&apos;, &apos;pluggy&apos;: &apos;0.8.1&apos;}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Windows-10-10.0.17763-SP0</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{&apos;hypothesis&apos;: &apos;4.6.0&apos;, &apos;metadata&apos;: &apos;1.8.0&apos;, &apos;html&apos;: &apos;1.20.0&apos;}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.7.2</td></tr></table>
    <h2>Summary</h2>
    <p>46 tests ran in 1.61 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="passed">2 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="failed">44 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable numeric" col="duration">Duration</th>
          <th>Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsCell.__eq__.txt::test__docstring_slyther.types.ConsCell.__eq__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Two cons cells are equal if each of their ``car`` and<br/>004 ``cdr`` are equal:<br/>005 <br/>006 &gt;&gt;&gt; a = ConsCell(1, 2)<br/>UNEXPECTED EXCEPTION: NotImplementedError(&#x27;Deliverable 1&#x27;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsCell.__eq__.txt[1]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 27, in __init__<br/>    raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><br/>NotImplementedError: Deliverable 1<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsCell.__eq__.txt:6: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsCell.__repr__.txt::test__docstring_slyther.types.ConsCell.__repr__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 A cons cell should ``repr`` itself in a format that would<br/>004 be parsable and evaluable to our language.<br/>005 <br/>006 &gt;&gt;&gt; ConsCell(1, 2)<br/>UNEXPECTED EXCEPTION: NotImplementedError(&#x27;Deliverable 1&#x27;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsCell.__repr__.txt[1]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 27, in __init__<br/>    raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><br/>NotImplementedError: Deliverable 1<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsCell.__repr__.txt:6: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsCell.txt::test__docstring_slyther.types.ConsCell.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 A simple cons cell data structure:<br/>004 <br/>005 &gt;&gt;&gt; cell = ConsCell(1, 2)<br/>UNEXPECTED EXCEPTION: NotImplementedError(&#x27;Deliverable 1&#x27;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsCell.txt[1]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 27, in __init__<br/>    raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><br/>NotImplementedError: Deliverable 1<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsCell.txt:5: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.__contains__.txt::test__docstring_slyther.types.ConsList.__contains__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Return ``True`` if the list contains an element ``p``, ``False``<br/>004 otherwise. A list is said to contain an element ``p`` iff there is any<br/>005 element ``a`` in the list such that ``a == p``.<br/>006 <br/>007 &gt;&gt;&gt; lst = [1, 1, 2, 3, 5, 8]<br/>008 &gt;&gt;&gt; clst = ConsList.from_iterable(lst)<br/>UNEXPECTED EXCEPTION: TypeError(&quot;&#x27;list&#x27; object is not an iterator&quot;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsList.__contains__.txt[2]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 158, in from_iterable<br/>    if(next(it, None)):<br/><br/>TypeError: &#x27;list&#x27; object is not an iterator<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.__contains__.txt:8: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.__eq__.txt::test__docstring_slyther.types.ConsList.__eq__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Test if two lists have the same elements in the same order.<br/>004 <br/>005 &gt;&gt;&gt; l1, l2 = map(<br/>UNEXPECTED EXCEPTION: TypeError(&quot;&#x27;list&#x27; object is not an iterator&quot;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsList.__eq__.txt[1]&gt;&quot;, line 3, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 158, in from_iterable<br/>    if(next(it, None)):<br/><br/>TypeError: &#x27;list&#x27; object is not an iterator<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.__eq__.txt:5: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.__getitem__.txt::test__docstring_slyther.types.ConsList.__getitem__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Get item at index ``idx``:<br/>004 <br/>005 &gt;&gt;&gt; lst = [1, 1, 2, 3, 5, 8]<br/>006 &gt;&gt;&gt; clst = ConsList.from_iterable(lst)<br/>UNEXPECTED EXCEPTION: TypeError(&quot;&#x27;list&#x27; object is not an iterator&quot;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsList.__getitem__.txt[2]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 158, in from_iterable<br/>    if(next(it, None)):<br/><br/>TypeError: &#x27;list&#x27; object is not an iterator<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.__getitem__.txt:6: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.__init__.txt::test__docstring_slyther.types.ConsList.__init__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 If the ``cdr`` was not provided, assume to be ``NIL``.<br/>004 <br/>005 &gt;&gt;&gt; cell = ConsList(1)<br/>UNEXPECTED EXCEPTION: NotImplementedError(&#x27;Deliverable 1&#x27;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsList.__init__.txt[1]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 122, in __init__<br/>    raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><br/>NotImplementedError: Deliverable 1<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.__init__.txt:5: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.__len__.txt::test__docstring_slyther.types.ConsList.__len__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Return the number of elements in the list:<br/>004 <br/>005 &gt;&gt;&gt; lst = [1, 1, 2, 3, 5, 8]<br/>006 &gt;&gt;&gt; len(ConsList.from_iterable(lst))<br/>UNEXPECTED EXCEPTION: TypeError(&quot;&#x27;list&#x27; object is not an iterator&quot;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsList.__len__.txt[2]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 158, in from_iterable<br/>    if(next(it, None)):<br/><br/>TypeError: &#x27;list&#x27; object is not an iterator<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.__len__.txt:6: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.__repr__.txt::test__docstring_slyther.types.ConsList.__repr__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Represent ourselves in a format evaluable in SlytherLisp.<br/>004 <br/>005 &gt;&gt;&gt; ConsList.from_iterable([1, 2, 3])<br/>UNEXPECTED EXCEPTION: TypeError(&quot;&#x27;list&#x27; object is not an iterator&quot;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsList.__repr__.txt[1]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 158, in from_iterable<br/>    if(next(it, None)):<br/><br/>TypeError: &#x27;list&#x27; object is not an iterator<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.__repr__.txt:5: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.__reversed__.txt::test__docstring_slyther.types.ConsList.__reversed__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Iterate over the elements of our list, reversed.<br/>004 <br/>005 &gt;&gt;&gt; lst = [1, 1, 2, 3, 5, 8]<br/>006 &gt;&gt;&gt; clst = ConsList.from_iterable(lst)<br/>UNEXPECTED EXCEPTION: TypeError(&quot;&#x27;list&#x27; object is not an iterator&quot;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsList.__reversed__.txt[2]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 158, in from_iterable<br/>    if(next(it, None)):<br/><br/>TypeError: &#x27;list&#x27; object is not an iterator<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.__reversed__.txt:6: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.cells.txt::test__docstring_slyther.types.ConsList.cells.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Iterate over eaCh cell (rather that the ``car`` of each):<br/>004 <br/>005 &gt;&gt;&gt; lst = [1, 1, 2, 3, 5, 8]<br/>006 &gt;&gt;&gt; for cell in ConsList.from_iterable(lst).cells():<br/>UNEXPECTED EXCEPTION: TypeError(&quot;&#x27;list&#x27; object is not an iterator&quot;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsList.cells.txt[2]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 158, in from_iterable<br/>    if(next(it, None)):<br/><br/>TypeError: &#x27;list&#x27; object is not an iterator<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.cells.txt:6: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.from_iterable.txt::test__docstring_slyther.types.ConsList.from_iterable.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Create an instance of ``cls`` from an iterable (anything that can go<br/>004 on the right hand side of a ``for`` loop).<br/>005 <br/>006 &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>007 &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>Expected:<br/>    [0, 1, 2, NIL]<br/>Got:<br/>    [NIL, NIL, NIL, NIL]<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.from_iterable.txt:7: DocTestFailure<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.ConsList.txt::test__docstring_slyther.types.ConsList.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 A ``ConsList`` inherits from a ``ConsCell``, but the ``cdr`` must<br/>004 be a ``ConsList`` or any structure which inherits from that.<br/>005 <br/>006 &gt;&gt;&gt; cell = ConsList(1, ConsList(2, NIL))<br/>UNEXPECTED EXCEPTION: NotImplementedError(&#x27;Deliverable 1&#x27;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.ConsList.txt[1]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 122, in __init__<br/>    raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><br/>NotImplementedError: Deliverable 1<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.ConsList.txt:6: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.LexicalVarStorage.__getitem__.txt::test__docstring_slyther.types.LexicalVarStorage.__getitem__.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">002 <br/>003 Return a Variable object, first checking the local<br/>004 environment, then checking the containing environment,<br/>005 otherwise raising a ``KeyError``.<br/>006 <br/>007 &gt;&gt;&gt; environ = {k: Variable(v) for k, v in ((&#x27;x&#x27;, 10), (&#x27;y&#x27;, 11))}<br/>008 &gt;&gt;&gt; stg = LexicalVarStorage(environ)<br/>009 &gt;&gt;&gt; stg.put(&#x27;y&#x27;, 12)<br/>010 &gt;&gt;&gt; stg.put(&#x27;z&#x27;, 13)<br/>011 &gt;&gt;&gt; stg[&#x27;x&#x27;].value<br/>UNEXPECTED EXCEPTION: NotImplementedError(&#x27;Deliverable 1&#x27;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.LexicalVarStorage.__getitem__.txt[5]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 600, in __getitem__<br/>    raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><br/>NotImplementedError: Deliverable 1<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.LexicalVarStorage.__getitem__.txt:11: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.LexicalVarStorage.fork.txt::test__docstring_slyther.types.LexicalVarStorage.fork.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Return the union of the ``local`` part and the ``environ``<br/>004 part. Should not modify either part.<br/>005 <br/>006 &gt;&gt;&gt; environ = {k: Variable(v) for k, v in ((&#x27;x&#x27;, 10), (&#x27;y&#x27;, 11))}<br/>007 &gt;&gt;&gt; stg = LexicalVarStorage(environ)<br/>008 &gt;&gt;&gt; stg.put(&#x27;y&#x27;, 12)<br/>009 &gt;&gt;&gt; stg.put(&#x27;z&#x27;, 13)<br/>010 &gt;&gt;&gt; for k, v in stg.fork().items():<br/>UNEXPECTED EXCEPTION: NotImplementedError(&#x27;Deliverable 1&#x27;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.LexicalVarStorage.fork.txt[5]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 564, in fork<br/>    raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><br/>NotImplementedError: Deliverable 1<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.LexicalVarStorage.fork.txt:10: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.SExpression.txt::test__docstring_slyther.types.SExpression.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 ConsList which we use to store s-expressions. Has an alternate<br/>004 representation.<br/>005 <br/>006 &gt;&gt;&gt; SExpression(4)<br/>UNEXPECTED EXCEPTION: NotImplementedError(&#x27;Deliverable 1&#x27;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.SExpression.txt[1]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 122, in __init__<br/>    raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><br/>NotImplementedError: Deliverable 1<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.SExpression.txt:6: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.cons.txt::test__docstring_slyther.types.cons.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">001 &gt;&gt;&gt; from slyther.types import *<br/>002 <br/>003 Factory for cons cell like things. Tries to make a ``ConsList`` or<br/>004 ``SExpression`` if it can (if ``cdr`` is...), otherwise makes a<br/>005 plain old ``ConsCell``.<br/>006 <br/>007 &gt;&gt;&gt; cons(5, ConsList(4, NIL))<br/>UNEXPECTED EXCEPTION: NotImplementedError(&#x27;Deliverable 1&#x27;)<br/>Traceback (most recent call last):<br/><br/>  File &quot;c:\users\carson\appdata\local\programs\python\python37\lib\doctest.py&quot;, line 1329, in __run<br/>    compileflags, 1), test.globs)<br/><br/>  File &quot;&lt;doctest test__docstring_slyther.types.cons.txt[1]&gt;&quot;, line 1, in &lt;module&gt;<br/><br/>  File &quot;c:\users\carson\mines-courses\mines courses\csci_400\slytherlisp\slyther\types.py&quot;, line 122, in __init__<br/>    raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><br/>NotImplementedError: Deliverable 1<br/><br/>C:\Users\Carson\Mines-Courses\Mines Courses\CSCI_400\SlytherLisp\tests\d1\test__docstring_slyther.types.cons.txt:7: UnexpectedException<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conscell.py::test_cons_init</td>
          <td class="col-duration">0.80</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects)<br/>&gt;   def test_cons_init(car, cdr):<br/><br/>tests\d1\test_conscell.py:14: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conscell.py:15: in test_cons_init<br/>    cell = ConsCell(car, cdr)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (cons NIL NIL), car = None, cdr = None<br/><br/>    def __init__(self, car, cdr):<br/>        if car is not None: self.car = car<br/>        else: self.car = NIL<br/>    <br/>        if cdr is not None: self.cdr = cdr<br/>        else: self.cdr = NIL<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:27: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cons_init(car=None, cdr=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conscell.py::test_cons_eq_self</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects)<br/>&gt;   def test_cons_eq_self(car, cdr):<br/><br/>tests\d1\test_conscell.py:21: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conscell.py:22: in test_cons_eq_self<br/>    cell = ConsCell(car, cdr)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (cons NIL NIL), car = None, cdr = None<br/><br/>    def __init__(self, car, cdr):<br/>        if car is not None: self.car = car<br/>        else: self.car = NIL<br/>    <br/>        if cdr is not None: self.cdr = cdr<br/>        else: self.cdr = NIL<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:27: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cons_eq_self(car=None, cdr=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conscell.py::test_cons_eq_others</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">def test_cons_eq_others():<br/>&gt;       a = ConsCell(1, 2)<br/><br/>tests\d1\test_conscell.py:30: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (cons 1 2), car = 1, cdr = 2<br/><br/>    def __init__(self, car, cdr):<br/>        if car is not None: self.car = car<br/>        else: self.car = NIL<br/>    <br/>        if cdr is not None: self.cdr = cdr<br/>        else: self.cdr = NIL<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:27: NotImplementedError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conscell.py::test_cons_eq_noncell</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects, simple_objects)<br/>&gt;   def test_cons_eq_noncell(car, cdr, other):<br/><br/>tests\d1\test_conscell.py:49: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conscell.py:50: in test_cons_eq_noncell<br/>    cell = ConsCell(car, cdr)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (cons NIL NIL), car = None, cdr = None<br/><br/>    def __init__(self, car, cdr):<br/>        if car is not None: self.car = car<br/>        else: self.car = NIL<br/>    <br/>        if cdr is not None: self.cdr = cdr<br/>        else: self.cdr = NIL<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:27: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cons_eq_noncell(car=None, cdr=None, other=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conscell.py::test_cons_repr</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects)<br/>&gt;   def test_cons_repr(car, cdr):<br/><br/>tests\d1\test_conscell.py:55: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conscell.py:56: in test_cons_repr<br/>    cell = ConsCell(car, cdr)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (cons NIL NIL), car = None, cdr = None<br/><br/>    def __init__(self, car, cdr):<br/>        if car is not None: self.car = car<br/>        else: self.car = NIL<br/>    <br/>        if cdr is not None: self.cdr = cdr<br/>        else: self.cdr = NIL<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:27: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cons_repr(car=None, cdr=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_init_fail</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects_nonone)<br/>&gt;   def test_init_fail(car, cdr):<br/><br/>tests\d1\test_conslist.py:19: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:21: in test_init_fail<br/>    ConsList(car, cdr)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;bool&#x27; object has no attribute &#x27;cdr&#x27;&quot;) raised in repr()] ConsList object at 0x24059632940&gt;, car = None<br/>cdr = False<br/><br/>    def __init__(self, car, cdr=None):<br/>        &quot;&quot;&quot;<br/>        If the ``cdr`` was not provided, assume to be ``NIL``.<br/>    <br/>        &gt;&gt;&gt; cell = ConsList(1)<br/>        &gt;&gt;&gt; cell.cdr<br/>        NIL<br/>        &quot;&quot;&quot;<br/>        self.car = car<br/>        if(cdr is None): self.cdr = NIL<br/>        else: self.cdr = cdr<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:122: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_init_fail(car=None, cdr=False)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_init_nil</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects)<br/>&gt;   def test_init_nil(car):<br/><br/>tests\d1\test_conslist.py:25: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:26: in test_init_nil<br/>    cell_a = ConsList(car, NIL)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (list), car = None, cdr = NIL<br/><br/>    def __init__(self, car, cdr=None):<br/>        &quot;&quot;&quot;<br/>        If the ``cdr`` was not provided, assume to be ``NIL``.<br/>    <br/>        &gt;&gt;&gt; cell = ConsList(1)<br/>        &gt;&gt;&gt; cell.cdr<br/>        NIL<br/>        &quot;&quot;&quot;<br/>        self.car = car<br/>        if(cdr is None): self.cdr = NIL<br/>        else: self.cdr = cdr<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:122: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_init_nil(car=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_init_nil_nil</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">def test_init_nil_nil():<br/>&gt;       cell_a = ConsList(NIL, NIL)<br/><br/>tests\d1\test_conslist.py:35: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (list), car = NIL, cdr = NIL<br/><br/>    def __init__(self, car, cdr=None):<br/>        &quot;&quot;&quot;<br/>        If the ``cdr`` was not provided, assume to be ``NIL``.<br/>    <br/>        &gt;&gt;&gt; cell = ConsList(1)<br/>        &gt;&gt;&gt; cell.cdr<br/>        NIL<br/>        &quot;&quot;&quot;<br/>        self.car = car<br/>        if(cdr is None): self.cdr = NIL<br/>        else: self.cdr = cdr<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:122: NotImplementedError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_twolist_init</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects)<br/>&gt;   def test_twolist_init(car, cadr):<br/><br/>tests\d1\test_conslist.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:45: in test_twolist_init<br/>    last = ConsList(cadr)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (list), car = None, cdr = None<br/><br/>    def __init__(self, car, cdr=None):<br/>        &quot;&quot;&quot;<br/>        If the ``cdr`` was not provided, assume to be ``NIL``.<br/>    <br/>        &gt;&gt;&gt; cell = ConsList(1)<br/>        &gt;&gt;&gt; cell.cdr<br/>        NIL<br/>        &quot;&quot;&quot;<br/>        self.car = car<br/>        if(cdr is None): self.cdr = NIL<br/>        else: self.cdr = cdr<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:122: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_twolist_init(car=None, cadr=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_nestlist_init</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects)<br/>&gt;   def test_nestlist_init(car):<br/><br/>tests\d1\test_conslist.py:54: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:55: in test_nestlist_init<br/>    inner = ConsList(car)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (list), car = None, cdr = None<br/><br/>    def __init__(self, car, cdr=None):<br/>        &quot;&quot;&quot;<br/>        If the ``cdr`` was not provided, assume to be ``NIL``.<br/>    <br/>        &gt;&gt;&gt; cell = ConsList(1)<br/>        &gt;&gt;&gt; cell.cdr<br/>        NIL<br/>        &quot;&quot;&quot;<br/>        self.car = car<br/>        if(cdr is None): self.cdr = NIL<br/>        else: self.cdr = cdr<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:122: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_nestlist_init(car=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_fromiterable</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(st.lists(simple_objects))<br/>&gt;   def test_fromiterable(lst):<br/><br/>tests\d1\test_conslist.py:64: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:69: in test_fromiterable<br/>    cell = ConsList.from_iterable(typ(lst))<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;slyther.types.ConsList&#x27;&gt;, it = []<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;list&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_fromiterable(lst=[])</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_fromiterable_set</td>
          <td class="col-duration">0.03</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(st.one_of(st.sets(simple_objects), st.frozensets(simple_objects)))<br/>&gt;   def test_fromiterable_set(s):<br/><br/>tests\d1\test_conslist.py:77: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:78: in test_fromiterable_set<br/>    cell = ConsList.from_iterable(s)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;slyther.types.ConsList&#x27;&gt;, it = set()<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;set&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_fromiterable_set(s=set())</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_fromiterable_big</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">def test_fromiterable_big():<br/>&gt;       cell = ConsList.from_iterable(range(10000))<br/><br/>tests\d1\test_conslist.py:88: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;slyther.types.ConsList&#x27;&gt;, it = range(0, 10000)<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;range&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_fromiterable_uses_cls</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">def test_fromiterable_uses_cls():<br/>        # this test is used to determine if the cls argument to<br/>        # from_iterable is used correctly, or fail if ConsList was<br/>        # hard-coded.<br/>    <br/>        class ExtType(ConsList):<br/>            pass<br/>    <br/>&gt;       cell = ExtType.from_iterable(range(10))<br/><br/>tests\d1\test_conslist.py:103: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;test_conslist.test_fromiterable_uses_cls.&lt;locals&gt;.ExtType&#x27;&gt;, it = range(0, 10)<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;range&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_getitem</td>
          <td class="col-duration">0.03</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(st.lists(simple_objects))<br/>&gt;   def test_getitem(lst):<br/><br/>tests\d1\test_conslist.py:112: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:113: in test_getitem<br/>    cell = ConsList.from_iterable(lst)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;slyther.types.ConsList&#x27;&gt;, it = []<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;list&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_getitem(lst=[])</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_iter</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(st.lists(simple_objects))<br/>&gt;   def test_iter(lst):<br/><br/>tests\d1\test_conslist.py:119: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:120: in test_iter<br/>    it = iter(ConsList.from_iterable(lst))<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;slyther.types.ConsList&#x27;&gt;, it = []<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;list&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_iter(lst=[])</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_cells</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(st.lists(simple_objects))<br/>&gt;   def test_cells(lst):<br/><br/>tests\d1\test_conslist.py:128: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:129: in test_cells<br/>    it = ConsList.from_iterable(lst).cells()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;slyther.types.ConsList&#x27;&gt;, it = []<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;list&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cells(lst=[])</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_len</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(st.lists(simple_objects))<br/>&gt;   def test_len(lst):<br/><br/>tests\d1\test_conslist.py:138: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:139: in test_len<br/>    cell = ConsList.from_iterable(lst)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;slyther.types.ConsList&#x27;&gt;, it = []<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;list&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_len(lst=[])</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_len_big</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">def test_len_big():<br/>        # build a list of length 10000<br/>&gt;       head = ConsList(NIL)<br/><br/>tests\d1\test_conslist.py:145: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (list), car = NIL, cdr = None<br/><br/>    def __init__(self, car, cdr=None):<br/>        &quot;&quot;&quot;<br/>        If the ``cdr`` was not provided, assume to be ``NIL``.<br/>    <br/>        &gt;&gt;&gt; cell = ConsList(1)<br/>        &gt;&gt;&gt; cell.cdr<br/>        NIL<br/>        &quot;&quot;&quot;<br/>        self.car = car<br/>        if(cdr is None): self.cdr = NIL<br/>        else: self.cdr = cdr<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:122: NotImplementedError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_contains</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(st.lists(simple_objects), simple_objects)<br/>&gt;   def test_contains(lst, other):<br/><br/>tests\d1\test_conslist.py:156: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:157: in test_contains<br/>    cell = ConsList.from_iterable(lst)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;slyther.types.ConsList&#x27;&gt;, it = []<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;list&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_contains(lst=[], other=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_conslist.py::test_repr</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(st.lists(simple_objects, min_size=1))<br/>&gt;   def test_repr(lst):<br/><br/>tests\d1\test_conslist.py:165: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_conslist.py:166: in test_repr<br/>    r = repr(ConsList.from_iterable(lst))<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>cls = &lt;class &#x27;slyther.types.ConsList&#x27;&gt;, it = [None]<br/><br/>    @classmethod<br/>    def from_iterable(cls, it):<br/>        &quot;&quot;&quot;<br/>        Create an instance of ``cls`` from an iterable (anything that can go<br/>        on the right hand side of a ``for`` loop).<br/>    <br/>        &gt;&gt;&gt; lst = ConsList.from_iterable(iter(range(3)))<br/>        &gt;&gt;&gt; [lst.car, lst.cdr.car, lst.cdr.cdr.car, lst.cdr.cdr.cdr]<br/>        [0, 1, 2, NIL]<br/>        &gt;&gt;&gt; ConsList.from_iterable([])<br/>        NIL<br/>    <br/>        Note: Your implementation is subject to the following constraints:<br/>    <br/>        :Time complexity: O(n), where n is length of ``it``<br/>        :Space complexity: O(n) ``ConsList`` objects,<br/>                           O(1) everything else (including stack frames!)<br/>        &quot;&quot;&quot;<br/>    <br/>        # try:<br/>        #     #Need to return list of ConCells<br/>        #     for i, value in enumerate(it):<br/>        #         cell_list = ConsList(value)<br/>        #         try:<br/>        #             cell_list.cdr = cls[i-1]<br/>        #         except:<br/>        #             cell_list.cdr = NIL<br/>        #<br/>        #         cls.append(cell_list)<br/>        # except:<br/>        #     return NIL<br/>    <br/>&gt;       if(next(it, None)):<br/><span class="error">E       TypeError: &#x27;list&#x27; object is not an iterator</span><br/><br/>slyther\types.py:158: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_repr(lst=[None])</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_factory.py::test_cons_onto_nil</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects)<br/>&gt;   def test_cons_onto_nil(car):<br/><br/>tests\d1\test_factory.py:13: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_factory.py:14: in test_cons_onto_nil<br/>    cell = cons(car, NIL)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>car = None, cdr = NIL<br/><br/>    def cons(car, cdr) -&gt; ConsCell:<br/>        &quot;&quot;&quot;<br/>        Factory for cons cell like things. Tries to make a ``ConsList`` or<br/>        ``SExpression`` if it can (if ``cdr`` is...), otherwise makes a<br/>        plain old ``ConsCell``.<br/>    <br/>        &gt;&gt;&gt; cons(5, ConsList(4, NIL))<br/>        (list 5 4)<br/>        &gt;&gt;&gt; cons(5, NIL)<br/>        (list 5)<br/>        &gt;&gt;&gt; cons(5, 4)<br/>        (cons 5 4)<br/>        &gt;&gt;&gt; cons(5, SExpression(4, NIL))<br/>        (5 4)<br/>        &quot;&quot;&quot;<br/>&gt;       if isinstance(ConsList, cdr) or cdr == NIL:<br/><span class="error">E       TypeError: isinstance() arg 2 must be a type or tuple of types</span><br/><br/>slyther\types.py:510: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cons_onto_nil(car=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_factory.py::test_cons_onto_conscell</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects, simple_objects)<br/>&gt;   def test_cons_onto_conscell(car, cadr, cddr):<br/><br/>tests\d1\test_factory.py:21: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_factory.py:22: in test_cons_onto_conscell<br/>    cdr = ConsCell(cadr, cddr)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (cons NIL NIL), car = None, cdr = None<br/><br/>    def __init__(self, car, cdr):<br/>        if car is not None: self.car = car<br/>        else: self.car = NIL<br/>    <br/>        if cdr is not None: self.cdr = cdr<br/>        else: self.cdr = NIL<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:27: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cons_onto_conscell(car=None, cadr=None, cddr=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_factory.py::test_cons_onto_conslist</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects)<br/>&gt;   def test_cons_onto_conslist(car, cadr):<br/><br/>tests\d1\test_factory.py:31: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_factory.py:32: in test_cons_onto_conslist<br/>    cdr = ConsList(cadr, NIL)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = (list), car = None, cdr = NIL<br/><br/>    def __init__(self, car, cdr=None):<br/>        &quot;&quot;&quot;<br/>        If the ``cdr`` was not provided, assume to be ``NIL``.<br/>    <br/>        &gt;&gt;&gt; cell = ConsList(1)<br/>        &gt;&gt;&gt; cell.cdr<br/>        NIL<br/>        &quot;&quot;&quot;<br/>        self.car = car<br/>        if(cdr is None): self.cdr = NIL<br/>        else: self.cdr = cdr<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:122: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cons_onto_conslist(car=None, cadr=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_factory.py::test_cons_onto_se</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects)<br/>&gt;   def test_cons_onto_se(car, cadr):<br/><br/>tests\d1\test_factory.py:41: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_factory.py:42: in test_cons_onto_se<br/>    cdr = SExpression(cadr, NIL)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[NotImplementedError(&quot;Deliverable 1&quot;) raised in repr()] SExpression object at 0x240596679e8&gt;, car = None, cdr = NIL<br/><br/>    def __init__(self, car, cdr=None):<br/>        &quot;&quot;&quot;<br/>        If the ``cdr`` was not provided, assume to be ``NIL``.<br/>    <br/>        &gt;&gt;&gt; cell = ConsList(1)<br/>        &gt;&gt;&gt; cell.cdr<br/>        NIL<br/>        &quot;&quot;&quot;<br/>        self.car = car<br/>        if(cdr is None): self.cdr = NIL<br/>        else: self.cdr = cdr<br/>    <br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:122: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cons_onto_se(car=None, cadr=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_factory.py::test_cons_onto_noncons</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(simple_objects, simple_objects)<br/>&gt;   def test_cons_onto_noncons(car, cdr):<br/><br/>tests\d1\test_factory.py:51: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_factory.py:52: in test_cons_onto_noncons<br/>    cell = cons(car, cdr)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>car = None, cdr = None<br/><br/>    def cons(car, cdr) -&gt; ConsCell:<br/>        &quot;&quot;&quot;<br/>        Factory for cons cell like things. Tries to make a ``ConsList`` or<br/>        ``SExpression`` if it can (if ``cdr`` is...), otherwise makes a<br/>        plain old ``ConsCell``.<br/>    <br/>        &gt;&gt;&gt; cons(5, ConsList(4, NIL))<br/>        (list 5 4)<br/>        &gt;&gt;&gt; cons(5, NIL)<br/>        (list 5)<br/>        &gt;&gt;&gt; cons(5, 4)<br/>        (cons 5 4)<br/>        &gt;&gt;&gt; cons(5, SExpression(4, NIL))<br/>        (5 4)<br/>        &quot;&quot;&quot;<br/>&gt;       if isinstance(ConsList, cdr) or cdr == NIL:<br/><span class="error">E       TypeError: isinstance() arg 2 must be a type or tuple of types</span><br/><br/>slyther\types.py:510: TypeError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_cons_onto_noncons(car=None, cdr=None)</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">tests/d1/test_storage.py::test_fork</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">@given(stg_dictionaries, stg_dictionaries)<br/>&gt;   def test_fork(environ, local):<br/><br/>tests\d1\test_storage.py:18: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>tests\d1\test_storage.py:23: in test_fork<br/>    fork = stg.fork()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;slyther.types.LexicalVarStorage object at 0x00000240596E1668&gt;<br/><br/>    def fork(self) -&gt; Dict[str, Variable]:<br/>        &quot;&quot;&quot;<br/>        Return the union of the ``local`` part and the ``environ``<br/>        part. Should not modify either part.<br/>    <br/>        &gt;&gt;&gt; environ = {k: Variable(v) for k, v in ((&#x27;x&#x27;, 10), (&#x27;y&#x27;, 11))}<br/>        &gt;&gt;&gt; stg = LexicalVarStorage(environ)<br/>        &gt;&gt;&gt; stg.put(&#x27;y&#x27;, 12)<br/>        &gt;&gt;&gt; stg.put(&#x27;z&#x27;, 13)<br/>        &gt;&gt;&gt; for k, v in stg.fork().items():<br/>        ...     print(k, v.value)<br/>        x 10<br/>        y 12<br/>        z 13<br/>        &quot;&quot;&quot;<br/>&gt;       raise NotImplementedError(&quot;Deliverable 1&quot;)<br/><span class="error">E       NotImplementedError: Deliverable 1</span><br/><br/>slyther\types.py:564: NotImplementedError<br/>---------------------------------- Hypothesis ----------------------------------<br/>Falsifying example: test_fork(environ={}, local={})</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.LexicalVarStorage.put.txt::test__docstring_slyther.types.LexicalVarStorage.put.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">tests/d1/test__docstring_slyther.types.LexicalVarStorage.txt::test__docstring_slyther.types.LexicalVarStorage.txt</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody></table></body></html>