#!/usr/bin/env python
# coding: utf-8

# <h1>Short Bio</h1>
# <img src="https://lh3.googleusercontent.com/VPxQpBRQI8th0G2m13H01OJSmd264mhbnxCTbCprcWqrdHXmt8hHj8EG6tDl0pzbsiN_-VoA8iDWtHIBlMLfyf-dnGydnOg0ihbaBNnzAZZ2-skc2Mx83V1SNaueZPPHsvQpgWUs4x9_80lL8mBxGGAIEWUXKi7R4J9YJt7dEVJ6gPJXmogaOU4PDC5TdJCGcpVvwIo128ObLGVRmykwO-IXdAQGUfOjtqT3gLPnFumhiCCub6V_2rsv2G949WwjSZOp-9FRjVyVW_C_eD97pKuy7bHKIC7PE5tyNJEIepdyj0980od3VclC44pvRBuc0y2ldaDLsKM2HnkwEwnEmEFuPoWq7cZcIG3L480B1Lqn8_jJZPmYQjooZC75Eqcr2yoVYud6WDmNk_oJmThcUfubiX19PsDbjOtCoaCwx7_FbloXxA4upfRzh7Fx97QJs99RY84qZw4UjZ-AkVGeOrljR0MwdexZlLapJ6PRY_mJ8j6umTX8hWiCouRErFm_sb6hTkZX_KBODnn56sBRQLMTtdXF9zHFtwqkOvQYdASIw288gTn8nN-t55tPTXLwhMWxiTGLgmlVmuVfbdGVM48Y_FSBEqozXhVdOib2N6BcPBYZANz4oP5HQlF-ILrdJh0YMH2-p03LFp886xfyGWZMgaGNl4jwSBbBwhtDdlx8UFPI4VF7QM7gpVOI=w930-h1240-no?authuser=0"  style="width:200px;display: inline">
# My name is Carson Stevens and this will be my last semester at School of Mines. 
# 
# 
# Grew up in Lakewood on the other side of Green Mountain, but want to move somewhere 'just different' after I graduate. Some of my hobbies include photography, 4wheeling, and reefkeeping. I love to play and tinker with Raspberry Pis and computer vision is a great tool to be able to use when programming with them. I also have yet to play in detail with Deep Learning and Computer Vision, so I am also very excited about that!
# 
# Here is one of my reef tanks under 420nm light:
# <img src="https://lh3.googleusercontent.com/iWOoxihUxwbQ8mltb7aNbEtsMv51j6M_ILTGGcmwD9xC9vFeUkb3Gqh7z6qZ4f9FXeMBWm8YlbBUqjtDgtMSJEtGIHQItIS-xXrlHeSx2-hw3ZjJlbaTI2OADOtuql6lXxO-YnKpYJ4cjkMmYn74D-hdm3moU89s3Z_eqlFgJdw5gzCdRPpGN-vsckBee7Ej3R9Rap4TVek5CuqJ4YZw8TioWdXIQyz0q2x6A_NKIe5eGd6ru9pFENSyLqDp_wElTwJi5UpP9LSqlLP2oi36FqEhfkTWg6VB8amAz1nQ6g1kw4OkkKlSor5inl_Pi6qF4Db2r42XltNP09mSRaKFsRFX2PFCAXf8CR9Gx0YdlKdmm4JWUk8SYVZJjnwopJfNh5RJJSZLHglXHAEajuUWHDRxU326iUPdcEgYU86KoMEKR3rpbUAa7YV-BHTiEuFu33EjFkBURJmKcN6ExGB8Zm2b_iH_-mz-bqooqWyWuvE4r5A7QFlxan2jI2oiScZfueAiEdNTpkyjFBpHHpYL82duaL3SjwIiCr_OAdSvGmv1u1NYskh1ZfGCsDrkKgHXLPXBqItQc0L5BFWD4K99IxJO9fVHG4I7s66iRUJyxRRpHWriqm25Pwc_HAieHfmuLlT3FpxhRH_Me3QEX3ev6Lr9pcZ1BKsWpd8CWa2e8WrIMu1gxB01C5YKv09E=w1024-h576-no?authuser=0">
#          
# Here are my bunnies Pax and Bella:
# <img src="https://piazza.com/redirect/s3?bucket=uploads&prefix=paste%2Fj6e9077gk2s3bx%2F12943e28fd25dc526db38be6f0c7db04b6ede5f55303b565adcbf81621d5d378%2FBuns.png">
# 
# <h1>Math Review Questions[35 pts]</h1>
# <h3>Answers Below</h3>
# 
# 1. Consider the matrix A=\begin{bmatrix} 
# 4 & -2 \\
# 1 & 1 
# \end{bmatrix}A = [ 4 − 2 1 1 ]
# 
# a. Compute the determinant of the matrix, |A|. 
# 
# b. Compute the trace of the matrix.
# 
# c. Which of the following matrices is the inverse of A?
# 
# (i) LaTeX: A^{-1} = \begin{bmatrix}
# 1/4 &-1/2\\
# 1 &1\\
# \end{bmatrix}A − 1 = [ 1 / 4 − 1 / 2 1 1 ]
# (ii) LaTeX: A^{-1} = \begin{bmatrix}
# 4 & 1\\
# -2 &1\\
# \end{bmatrix}A − 1 = [ 4 1 − 2 1 ]
# (iii) LaTeX: A^{-1} = \begin{bmatrix}
# 1/6 &1/3\\
# -1/6 &2/3\\
# \end{bmatrix}A − 1 = [ 1 / 6 1 / 3 − 1 / 6 2 / 3 ]
# 
# d. Which of the following vectors is the eigenvector of A? 
# 
# (i) x = (-1 2)T
# (ii) x = (2 1)T
# (iii) x = (0 1)T
# (iv) x = (1 0)T
# 
# e. What is the corresponding eigenvalue?
# 
# 2. Consider the matrix LaTeX: B\:=\:\begin{bmatrix} 
# 3 & 4 \\
# 5 & -1 
# \end{bmatrix}B = [ 3 4 5 − 1 ]
# 
# a. Compute (AB)T
# 
# b. Compute BTAT
# 
# 3. Consider the vectors x = (1 2 3)T and y = (-1 2 -3)T.
# 
# a. Compute the inner (dot) product LaTeX: x\cdot yx ⋅ y
# b. Compute the vector (cross) product LaTeX: x \times yx × y
# 
# 4. The faces of a 10-sided die are numbered 0 through 9.
# 
# a. If the die is rolled, what is the probability that the value of the roll is a prime number?
# b. What is the expected value of the roll?
# c. If the die is rolled twice, what is the probability that the same number is obtained both times?
# 
# 5. Pull a card at random from a deck of cards.  What is the conditional probability that the card is the ace of clubs, given that it is a black card?
# 
# 6. A company makes widgets from three machines.  Machine M1 makes 3000/hour, and 80% are good.  Machine M2 makes 4000/hour, and 90% are good.  Machine M3 makes 3000/hour, and 60% are good.  All widgets are mixed together.  What is the probability that a widget drawn at random is good (hint: use marginalization)?
# 
# 7. A medical test shows that a person has a disease.  What is the probability that the person actually has the disease (hint: use Bayes' rule)?  Here's what we know about the disease and the test:
# 
# 1 in 100 people have the disease. That is, if D is the event that a randomly selected individual has the disease, then p(D) = 0.01.
# If H is the event that a randomly selected individual is healthy, then p(H) = 0.99.
# If a person has the disease, then the probability that the blood test comes back positive is 0.95. That is, p(T+ | D) = 0.95.
# If a person is healthy, then the probability that the diagnostic test comes back negative is 0.95. That is, p(T− | H) = 0.95.
# 
# <h1>Math Review Answers</h1>
# 
# 1a. (4\*1)-(-2\*1) ===> 6
# 
# 1b. (4+1) ===> 5
# 
# 1c. iii
# 
# 1d. 
# 
# 
# (-x+4 * -x+1) + 2 = x^2 - 5x + 6 = (x - 3)(x -2) = 3,2 
# 
#     
#     
#     (4x - 2y) = 3x   => 1x - 2y = 0
#     
#     (1x + 1y) = 3y   => (1x - 2y = 0)
#     
#     => [2
#     
#         1]
#         
#      
#      
#     (4x -2y) = 2x   => 2x - 2y = 0
#     
#     (1x + 1y) = 2y   => (1x - 1y = 0)
#     
#     => [1
#     
#         1]
# 
# 
# 
#     ===> ii
# 
# 1e. 3
# 
# 
# 
# 
# 2a. 
# 
# \[(4\*3)+(-2\*5)  (4\*4)+(-2\*-1)]
# 
# \[(1\*3)+(1\*5)   (1\*4)+(-1\*1)]
# 
#     [2  18]       [2  8] 
#     [8  3 ] ===>  [18 3]
# 
# 
# 
# 
# 2b. 
# 
# \[3   5]   [4  1]    [(3\*4)+(5\*-2)    (3\*1)+(5\*1)]         
# 
# \[4  -1] . [-2 1] => [(4\*4)+(-1\*-2)  (4\*1)+(-1\*1)]  
# 
# ===> [2   8]
# 
#      [18 3]
# 
# 
# 
# 
# 3a. 
# 
# [1        [-1       
#  
#  2    .     2   =>  -1+4-9 ===> -6
#      
#  3]        -3]       
# 
# 
# 
# 
# 3b. 
# 
# [1        [-1         
# 
#  2    x     2   ===>    [-12 0 4]
#      
#  3]        -3]          
# 
# 
# 
# 4a. Primes: 2,3,5,7 => (4/10) ===> 40%
# 
# 4b. (0+1+2+3+4+5+6+7+8+9)/10 ===> 4.5
# 
# 4c. 1/10 * 1/10 = 1/100 ===> 1%
# 
# 
# 
# 5.  (1/26)
# 
# 
# 
# 6.  ((3000*0.8)+ (4000*0.9) + (3000*0.6))/(3000+4000+3000)  
# 
# =>  7800/10000 
# 
# ===> 78%
# 
# 
# 
# 7.  (0.01)(0.95)/((0.01*0.95) + (1-0.01)*0.95)  
# 
# => 0.0095/(0.0095+0.9405)
# 
# => 0.0095/0.95 = 0.01 
# 
# ===> 0.0001%
# 
# 
# <h1>Python Programming</h1>
# 
# Python file attached also.
# 

# In[11]:




# In[1]:


import numpy as np
import math as m

A = np.array([[4,-2],[1,1]])
B = np.array([[3,4],[5,-1]])
x = np.transpose(np.array([1,2,3]))
y = np.transpose(np.array([-1,2,-3]))
w, v = np.linalg.eig(A)

# In[2]:


def guassianFunction(kernel, sigma, method="loops"):
    size = kernel.shape[0]
    
    if method == "numpy":
        # numpy.fromfunction() referenced from: https://stackoverflow.com/questions/47369579/how-to-get-the-gaussian-filter
        return np.fromfunction(lambda x, y: (1/(2*np.pi*sigma**2)) * np.e ** ((-1*((x-(size-1)/2)**2+(y-(size-1)/2)**2))/(2*sigma**2)), (size,size))
    
    elif method =="loops":
        for x,row in enumerate(kernel):
            for col, y in enumerate(row):
                kernel[x][col]=(1/(2*np.pi*sigma**2)) * np.e ** ((-1*((x-(size-1)/2)**2+(y-(size-1)/2)**2))/(2*sigma**2))
        return kernel

def guassianKernel(mu, sigma,size=9,method="loops",normalize=True, rounding=None):
    x1 = np.linspace(-mu,mu,size)
    y1 = np.linspace(-mu,mu,size)
    kernel = np.meshgrid(x1, y1)[0]
    
    kernel = guassianFunction(kernel,sigma,method)
    if normalize: kernel /= np.sum(kernel)
    if rounding: kernel = np.round(kernel,rounding)
        
    return kernel


# In[3]:


print("A:\n",A,"\nB:\n",B)
print("\nx: ",x,"\ny: ",y)
print("\n\nDeterminant of A: {}".format(np.linalg.det(A)))
print("\nTrace of A: {}".format(np.trace(A)))
print("\nTranspose of A:\n {}".format(np.transpose(A)))
print("\nInverse of A:\n {}".format(np.linalg.inv(A)))
print("\nEigenvalues of A: {}".format(np.linalg.eigvals(A)))
print("\nEigenvector from Eigenvalue 2: {}".format(v[:,1]))#[1,1]^T)
# print(v[:,0]) #[2,1]^T for eigenvalue 3
print("\n(AB)^T:\n {}".format(np.transpose(np.dot(A,B))))
print("\n(B^T)(A^T):\n {}".format(np.dot(np.transpose(B), np.transpose(A))))
print("\nx . y: {}".format(np.dot(x,y)))
print("\nx X y: {}".format(np.cross(x,y)))
print("\n\nSymmetric Guassian Kernel:\n", guassianKernel(1,1,size=9,method="numpy",rounding=7))
print("\n\nKernel Sum: ", guassianKernel(1,1,size=9,method="numpy").sum())

try:
    print("\n\tNumpy fromfunction method time: ")
    get_ipython().run_line_magic('timeit', 'guassianKernel(1,1,size=9,method="numpy")')
except:
    print("\t\t\tTimeit magic functionality only in Jupyter")
    
try:
    print("\n\t2 For loop method time: ")
    get_ipython().run_line_magic('timeit', 'guassianKernel(1,1,size=9,method="loops")')
except:
    print("\t\t\tTimeit magic functionality only in Jupyter")

